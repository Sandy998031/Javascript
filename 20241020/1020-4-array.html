<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>陣列</title>
</head>

<body>
  <script>
    let vipUserName = 'Loki';  //value of str(使用駝峰式大小寫)
    let vipUserAge = 12;  //val of num

    let myAryAA = new Array();  //正式宣告，透過內建建構式(產生一個大型物件，裡面包含一些可用的原生鍊prototype)來完成，一般人偷懶不使用
    let myAryAB = [];  //空陣列的語法糖果，暴力指定給變數
    let myAryAC = new Array(1, 2, 'A', true);
    let myAryB = ['A', true, 3];
    //myAryB.push('str'); //後面加入一個
    //myAryB.pop();  //後面拉出一個
    //myAryB.shift();  //前面拉出一個
    myAryB.unshift(456)  //前面加入一個


    //let myAry=[];  //val of array，可以指定n個值，每個值有自己的index(索引)
    //let myAry=['A',true,3];
    //myAry[0] //可以透過索引值找到對應的值做更改，0=A.1=true.2=3

    //根據push.pop.shift.unshift來操作陣列增減長度與內容

    //工作上不太使用
    let aryInit = [1, 2, 3];  //預設值
    //let errCloneAry=aryInit;  //預設arry因為指定，他們記憶體位置都一樣，這叫記憶體汙染
    //(一個陣列變動，直接影響另一個陣列跟著變動)


    //工作上使用
    let realCloneAry = [...aryInit];  //ES6解結構與重新建構，將陣列拆開，重新組合新陣列，再指定給b

    let a = [1, 2, 3];  //被複製的固定陣列
    let b = [...a];  //重構出一乾淨的陣列，指定給b
    b.push('A');
    console.log(b);  //b與a是不同的陣列，他們記憶體位置不同

    let c = [...a, 'Loki', ...b];  //重構時，再塞東西進去
    //[1,2,3,Loki,1,2,3,A]

    /////巢狀Array，二(N)維陣列/////////////////////////////////////////////
    function hello() {
      console.log('hello');
    }

    let MinAry = ['A', 'B', 'C']
    let BigAry = [hello,MinAry] 
    //前面的hello網頁顯示為一個function
    //可以用BigAry[1][1]找到'B'

    //const主要是保護變數有無重新指定
    //push或其他行為...都是可以被接受的(記憶體未改變)!!!!
    //但是結構與重構不行，因為他是重構出一乾淨的陣列(記憶體改變)!!!
    const ary2 = [1, 2, 3];
    ary2.push('A');  //[1,2,3,'A']


  </script>
</body>

</html>